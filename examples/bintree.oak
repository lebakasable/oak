use std.io
use std.array

alias Node_Index int

struct Node {
   value int
   left Node_Index
   right Node_Index
}

const NODES_CAP = 1024
let nodes [NODES_CAP]Node
let nodes_count = 1

fn node_new(value Node_Index) Node_Index {
   assert nodes_count < NODES_CAP
   nodes[nodes_count].value = value
   nodes_count += 1
   return nodes_count - 1
}

fn generate_tree(level Node_Index) Node_Index {
   if level > 0 {
      let node = node_new(nodes_count)
      nodes[node].left = generate_tree(level - 1)
      nodes[node].right = generate_tree(level - 1)
      return node
   }
   return 0
}

fn invert_tree_rec(root Node_Index) Node_Index {
   if root != 0 {
      let node = node_new(nodes[root].value)
      nodes[node].left = invert_tree_rec(nodes[root].right)
      nodes[node].right = invert_tree_rec(nodes[root].left)
      return node
   }
   return 0
}

fn print_tree_rec(root Node_Index, level int) {
   if root != 0 {
      print_tree_rec(nodes[root].left, level + 1)
      for let i = 0, i < level, i += 1 {
         &stdout << "  "
      }
      &stdout << nodes[root].value << "\n"
      print_tree_rec(nodes[root].right, level + 1)
   }
}

alias Action_Kind int
const (
   ACTION_CALL
   ACTION_HANDLE
)

struct Action {
   kind Action_Kind
   root Node_Index
   level int
}

fn action_new(kind Action_Kind, root Node_Index, level int) Action {
   let action Action
   action.kind = kind
   action.root = root
   action.level = level
   return action
}

struct Action_Stack {
   data *Action
   count int
   capacity int
}

fn action_stack_new() Action_Stack {
   let stack Action_Stack
   stack.data = 0 as *Action
   stack.count = 0
   stack.capacity = 0
   return stack
}

fn [<<](stack *Action_Stack, action Action) *Action_Stack {
   *(array_push(&stack.data as **char, &stack.count, &stack.capacity, sizeof(Action)) as *Action) = action
   return stack
}

fn action_stack_pop(stack *Action_Stack) Action {
   stack.count -= 1
   return stack.data[stack.count]
}

fn invert_tree_nonrec(root Node_Index) Node_Index {
   let arg_stack = action_stack_new()
   &arg_stack << action_new(ACTION_CALL, root, 0)
   let ret_stack [1024]Node_Index
   let ret_stack_count = 0
   for arg_stack.count > 0 {
      let action = action_stack_pop(&arg_stack)
      match action.kind {
         ACTION_CALL => if action.root != 0 {
            &arg_stack << action_new(ACTION_HANDLE, action.root, 0)
            &arg_stack << action_new(ACTION_CALL, nodes[action.root].right, 0)
            &arg_stack << action_new(ACTION_CALL, nodes[action.root].left, 0)
         } else {
            ret_stack[ret_stack_count] = 0
            ret_stack_count += 1
         }
         ACTION_HANDLE => {
            ret_stack_count -= 1
            let left = ret_stack[ret_stack_count]
            ret_stack_count -= 1
            let right = ret_stack[ret_stack_count]
            let ret = node_new(nodes[action.root].value)
            nodes[ret].left = left
            nodes[ret].right = right
            ret_stack[ret_stack_count] = ret
            ret_stack_count += 1
         }
      }
   }

   ret_stack_count -= 1
   return ret_stack[ret_stack_count]
}

fn print_tree_nonrec(root Node_Index) {
   let stack = action_stack_new()
   &stack << action_new(ACTION_CALL, root, 0)
   for stack.count > 0 {
      let action = action_stack_pop(&stack)
      match action.kind {
         ACTION_CALL => if action.root != 0 {
            &stack << action_new(ACTION_CALL, nodes[action.root].right, action.level + 1)
            &stack << action_new(ACTION_HANDLE, action.root, action.level)
            &stack << action_new(ACTION_CALL, nodes[action.root].left, action.level + 1)
         }
         ACTION_HANDLE => {
            for let i = 0, i < action.level, i += 1 {
               &stdout << "  "
            }
            &stdout << nodes[action.root].value << "\n"
         }
      }
   }
}

fn main() {
   let tree = generate_tree(3)
   print_tree_nonrec(tree)
   &stdout << "------------------------------\n"
   print_tree_nonrec(invert_tree_nonrec(tree))
}
