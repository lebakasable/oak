use std.io
use std.array

const LEFT = -1
const STAY = 0
const RIGHT = 1

struct State {
   write bool
   dir int
   next int
}

struct Inst {
   expected bool
   yes State
   no State
}

fn inst_new(expected bool, yes_write bool, yes_dir int, yes_next int, no_write bool, no_dir int, no_next int) Inst {
   let inst Inst
   inst.expected = expected
   inst.yes.write = yes_write
   inst.yes.dir = yes_dir
   inst.yes.next = yes_next
   inst.no.write = no_write
   inst.no.dir = no_dir
   inst.no.next = no_next
   return inst
}

struct Tape {
   data *bool
   count int
   capacity int
}

fn tape_randomize(tape *Tape) {
   srand(time(0 as *int))
   for let i = 0, i < tape.count, i += 1 {
      tape.data[i] = (real_rand()%2) as bool
   }
}

struct Machine {
   tape Tape
   head int
}

fn machine_new(size int) Machine {
   let machine Machine
   machine.tape.data = malloc(size) as *bool
   machine.tape.count = size
   machine.tape.capacity = size
   machine.head = 0
   return machine
}

fn machine_execute(machine *Machine, inst Inst, insts_count int) int {
   if machine.head >= machine.tape.count {
      *(array_push(&machine.tape.data as **char, &machine.tape.count, &machine.tape.capacity, sizeof(bool)) as *bool) = false
   }

   if machine.tape.data[machine.head] == inst.expected {
      machine.tape.data[machine.head] = inst.yes.write
      if machine.head == 0 && inst.yes.dir < 0 { return insts_count }
      machine.head += inst.yes.dir
      return inst.yes.next
   }
   machine.tape.data[machine.head] = inst.no.write
   if machine.head == 0 && inst.no.dir < 0 { return insts_count }
   machine.head += inst.no.dir
   return inst.no.next
}

fn machine_print(machine *Machine) {
   &stdout << "head: " << machine.head << ", "
   for let i = 0, i < machine.tape.count, i += 1 {
      if i > 0 { &stdout << " -> " }
      &stdout << machine.tape.data[i] as int
   }
   &stdout << "\n"
}

struct Program {
   machine *Machine
   insts *Inst
   insts_count int
   insts_capacity int
   cur int
}

fn program_new(machine *Machine) Program {
   let program Program
   program.machine = machine
   program.insts = 0 as *Inst
   program.insts_count = 0
   program.insts_capacity = 0
   program.cur = 0
   return program
}

fn [<<](program *Program, inst Inst) *Program {
   *(array_push(&program.insts as **char, &program.insts_count, &program.insts_capacity, sizeof(Inst)) as *Inst) = inst
   return program
}

fn main() {
   let machine Machine
   if argc == 0 {
      machine = machine_new(8)
      tape_randomize(&machine.tape)
   } else {
      machine = machine_new(strlen(argv[0]))
      for let i = 0, i < machine.tape.count, i += 1 {
         machine.tape.data[i] = argv[0][i] != '0'
      }
   }

   let program = program_new(&machine)
   &program << inst_new(false, true, RIGHT, 2, false, RIGHT, 0)

   machine_print(program.machine)
   for program.cur < program.insts_count {
      program.cur = machine_execute(program.machine, program.insts[program.cur], program.insts_count)
      machine_print(program.machine)
   }
}
